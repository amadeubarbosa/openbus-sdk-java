\documentclass[12pt]{article}

%% Estilos e Plug-Ins
\usepackage{a4}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{epsfig}
\usepackage{mwlabinputs}
\usepackage{hyperref}

\setlength{\parskip}{6mm}
\textheight=8.2in

%% Redefines the label 'Listing' to ..                                            
\def\lstlistingname{Código}                                                       
\lstset{inputencoding=latin1}                                                     
\codestyle{colorful}                                                              
%% Removes hyperlinks borders                                                     
\hypersetup{                                                                      
  pdfborder = {0 0 0},                                                            
}

\newcommand{\code}[1]{\texttt{#1}}

% ===================
% Inicio do documento
% ===================

\begin{document} 

\title{Tutorial do SDK Java do OpenBus}
\author{C. Augusto, R. Cosme, R. Cerqueira, M. Gatti \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{}
\maketitle


\pagenumbering{arabic}

\section{Introdução}

Este documento é destinado aos usuários desenvolvedores de aplicações Java que desejem utilizar o OpenBus. O processo de \emph{deployment} do barramento não é coberto aqui neste tutorial. Considera-se como pré-requisito para um bom entendimento deste documento o conhecimento básico dos seguintes assuntos:

\begin{itemize}
	\item Linguagem de programação Java.
	\item CORBA.
	\item Modelo de Componentes SCS.
	\item Conceitos básicos do Openbus.
\end{itemize}

\section{Preparação do Ambiente}

O OpenBus utiliza o mecanismo de interceptação de CORBA no processo de controle de acesso aos serviços. Após a chamada de requisição de \emph{login} no barramento, todas as chamadas seguintes devem estar com a credencial de acesso anexada. Sendo assim, faz-se necessário a habilitação dos interceptadores frente ao ORB que será utilizado. No OpenBus-Java o ORB utilizado será o JacORB, e o barramento se encarregará da instalação dos interceptadores em sua inicialização, não sendo necessária nenhuma ação por parte do usuário nesse aspecto.

\subsection{JacORB}\label{jacorb}

Devido à máquina virtual Java contar com seu próprio ORB, certas configurações são necessárias para que o JacORB seja utilizado em seu lugar. Essas configurações podem ser vizualizadas no Código~\ref{lst:jacoconfig}. O conjunto de propriedades deverá ser repassado posteriormente ao barramento, em sua inicialização, como veremos mais adiante.

\begin{labeledcode}[java]{jacoconfig}{Configurações para a Carga do JacORB}
import java.util.Properties;

Properties props = new Properties();
props.setProperty("org.omg.CORBA.ORBClass", "org.jacorb.orb.ORB");
props.setProperty("org.omg.CORBA.ORBSingletonClass",
  "org.jacorb.orb.ORBSingleton");
\end{labeledcode}

\subsection{Preparação do Ambiente com Mecanismo de Tolerância a Falhas}
O barramento possui um mecanismo de tolerância a falhas baseado em replicação. Ou seja, pode existir mais de uma réplica do componente do Serviço de Controle de Acesso ou do Serviço de Registro ativos em um dado momento. Para que este mecanismo possa funcionar corretamente, é preciso configurar os endereços das réplicas do Serviço de Controle de Acesso acessíveis no arquivo \textit{"/resources/FaultToleranceConfiguration.properties"}.

O mecanismo percorre de forma cíclica a lista de endereços especificadas por \textit{host:port} e separadas por vírgulas no atributo \textit{hosts} em caso de falha recebida pelo servidor. Além disso, existe o atributo \textit{trials} que representa a quantidade máxima de iterações que o mecanismo deve executar na busca por uma réplica ativa.

\subsection{Teste}

Antes de se começar a programação, é aconselhável que o usuário coloque em funcionamento a demo Hello que acompanha o pacote. O correto funcionamento da demo elimina uma série de possíveis problemas que o desenvolvedor possa enfrentar durante o seu projeto, como por exemplo: problemas de comunicação com o barramento, serviços básicos não disponíveis e ausência de bibliotecas externas.

Naturalmente a execução da demo necessita de um barramento em operação. A demo pode ser executada seguindo os seguintes passos:

\begin{itemize}
  \item Entrar no diretório \$OPENBUS\_HOME/demo/hello/java/resources e configurar a localização do barramento no arquivo Hello.properties.
  \item Executar o processo servidor da classe
% NOTA: incluindo um espaço no path para realizar uma quebra de linha no pdf
\$OPENBUS\_HOME/demo/hello/java/src/ tecgraf/openbus/demo/hello/HelloServer.java.
  \item Executar o processo cliente da classe 
% NOTA: incluindo um espaço no path para realizar uma quebra de linha no pdf
\$OPENBUS\_HOME/demo/hello/java/src/ tecgraf/openbus/demo/hello/HelloClient.java. Após a execução do cliente, no 
terminal do processo servidor a seguinte mensagem deve ser exibida: ``Hello !!!"
\end{itemize}

Após a execução do cliente, no terminal a seguinte mensagem deve ser exibida pelo processo servidor, entre outras: ``HELLO!"

\section{Desenvolvimento}

\subsection{API}\label{api}

A API é composta pela classe Openbus e pela classe \emph{stub} IRegistryService, referente ao Serviço de Registro. A classe Openbus atualmente é implementada como o padrão \emph{singleton}, pois suporta apenas um barramento. Para obter-se a instância do barramento e inicializá-la, deve-se utilizar o Código~\ref{lst:barramento}.

\begin{labeledcode}[java]{barramento}{Obtenção da Instância do Barramento}
import tecgraf.openbus.Openbus;

Openbus bus = Openbus.getInstance();

// host e porta apenas para fins de exemplo.
// args são argumentos da linha de comando e props são propriedades como as
// do Código 1. Ambos serão passados ao ORB em sua inicialização.
bus.init(args, props, "localhost", 2089);
\end{labeledcode}

Um ORB e POA são criados implicitamente na chamada \emph{init}.

Adicionalmente, para que o cliente possa se beneficiar do mecanismo de tolerância a falhas de forma transparente, é necessário inicializar o barramento com o mecanismo habilitado. Para isto, ao invés de inicializar usando o método \emph{init}, deve-se usar o método \emph{initWithFaultTolerance} passando os mesmos parâmetros tal como usado no método \emph{init}.

Se os endereços das réplicas do Serviço de Controle de Acesso acessíveis estiverem devidamente configurados, a API tentará redirecionar a chamada para uma réplica sem falha sempre que houver uma das seguintes falhas durante uma requisição:

\begin{verbatim}
  IDL:omg.org/CORBA/NO_RESPONSE:1.0
  IDL:omg.org/CORBA/COMM_FAILURE:1.0
  IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0
  IDL:omg.org/CORBA/TRANSIENT:1.0
  IDL:omg.org/CORBA/TIMEOUT:1.0
  IDL:omg.org/CORBA/NO_RESOURCES:1.0
  IDL:omg.org/CORBA/FREE_MEM:1.0
  IDL:omg.org/CORBA/NO_MEMORY:1.0
  IDL:omg.org/CORBA/INTERNAL:1.0
\end{verbatim}

Os outros métodos da API Openbus serão explicados em mais detalhes a seguir:

\begin{itemize}
  \item \code{Openbus getInstance()}: Fornece a única instância do barramento.
  
  \item \code{ORB getORB()}: Retorna o ORB utilizado.
  
  \item \code{POA getRootPOA()}: Retorna o RootPOA.
  
  \item \code{void run()}: \emph{Loop} que processa requisições remotas. Execução de \emph{orb.run()}.
  
  \item \code{void destroy()}: Finaliza a execução do barramento.
  
  \item \code{IComponent getACSIComponent()}: Retorna o \emph{stub} IComponent do Serviço de Controle de Acesso.
  
  \item \code{IAccessControlService getAccessControlService()}: Retorna o \emph{stub} do Serviço de Controle de Acesso.
  
  \item \code{IRegistryService getRegistryService()}: Retorna o \emph{stub} do Serviço de Registro.
  
  \item \code{ILeaseProvider getLeaseProvider()}: Retorna o \emph{stub} do Provedor de Lease do Serviço de Controle de Acesso.
  
  \item \code{IFaultTolerantService getACSFaultTolerantService()}: Retorna o \emph{stub} da faceta de Tolerância a Falhas do Serviço de Controle de Acesso.
  
  \item \code{Credential getCredential()}: Retorna a credencial de identificação do usuário frente ao barramento.
  
  \item \code{CredentialValidationPolicy getCredentialValidationPolicy()}: Retorna a política de validação de credencial em uso.
  
  \item \code{Credential getInterceptedCredential()}: Retorna a credencial interceptada pelo interceptador servidor. Esta operação somente deve ser chamada durante o tratamento de alguma requisição à aplicação do usuário.
  
  \item \code{void setThreadCredential(Credential credential)}: Define uma credencial a ser utilizada no lugar da credencial corrente. Útil para fornecer uma credencial com o campo delegate preenchido.
  
  \item \code{void setLeaseExpiredCallback(LeaseExpiredCallback lec)}: Registra uma callback para a notificação de que o lease da credencial	de identificação do usuário expirou.
  
  \item \code{void removeLeaseExpiredCallback(LeaseExpiredCallback lec)}: Remove uma callback previamente registrada para a notificação de lease expirado.
  
  \item \code{boolean isConnected()}: Informa o estado de conexão com o barramento.
  
  \item \code{IRegistryService connect(String user, String password)}: Realiza uma tentativa de conexão com o barramento. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, as seguintes exceções além das de CORBA podem ser lançadas:
    \subitem \code{ACSLoginFailureException}: O par nome de usuário e senha não foram validados.
    \subitem \code{ACSUnavailableException}: Caso o Serviço de Controle de Acesso não consiga ser contactado.
    \subitem \code{ServiceUnavailableException}: Caso algum serviço não seja contactado.
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
    \subitem \code{IllegalArgumentException}: Caso o método receba argumentos inválidos.
    \subitem \code{CORBAException}: Representa uma exceção gerada pelo runtime de CORBA.
    \subitem \code{OpenBusException}: Representa uma exceção genérica associada ao OpenBus.
  
  \item \code{IRegistryService connect(String name, RSAPrivateKey privateKey, X509Certificate acsCertificate)}: Realiza uma tentativa de conexão com o barramento, utilizando o mecanismo de certificação para o processo de autenticação. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, as seguintes exceções além das de CORBA podem ser lançadas:
    \subitem \code{ACSLoginFailureException}: O certificado não foi validado.
    \subitem \code{ServiceUnavailableException}: Caso algum serviço não seja contactado.
    \subitem \code{PKIException}: Os dados de certificado fornecidos não são válidos.
    \subitem \code{ACSUnavailableException}: Caso o Serviço de Controle de Acesso não consiga ser contactado.
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
    \subitem \code{IllegalArgumentException}: Caso o método receba argumentos inválidos.
    \subitem \code{CORBAException}: Representa uma exceção gerada pelo runtime de CORBA.
    \subitem \code{OpenBusException}: Representa uma exceção genérica associada ao OpenBus.
  
  \item \code{IRegistryService connect(Credential credential)}: Realiza uma tentativa de conexão ao barramento, a partir de uma credencial já existente. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, as seguintes exceções além das de CORBA podem ser lançadas:
    \subitem \code{ACSUnavailableException}: Caso o Serviço de Controle de Acesso não consiga ser contactado.
    \subitem \code{ServiceUnavailableException}: Caso algum serviço não seja contactado.
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
    \subitem \code{IllegalArgumentException}: Caso o método receba argumentos inválidos.
    \subitem \code{CORBAException}: Representa uma exceção gerada pelo runtime de CORBA.
    \subitem \code{OpenBusException}: Representa uma exceção genérica associada ao OpenBus.
  
  \item \code{IRegistryService connect(String entityName, InputStream 
keyStoreInputStream, char[] keyStorePassword, \\String entityKeyStoreAlias, 
char[] entityKeyStorePassword, String openbusKeyStoreAlias)}: Realiza uma 
tentativa de conexão com o barramento, via certificado. A chave privada da 
entidade e o certificado do barramento são carregados a partir de um repositório 
\emph{KeyStore}. As seguintes exceções, além das de CORBA, podem ser lançadas:
    \subitem \code{IllegalArgumentException}: Caso o método receba argumentos inválidos.
    \subitem \code{OpenBusException}: Representa uma exceção genérica associada ao OpenBus.
  
  \item \code{boolean disconnect()}: Desfaz a conexão atual.
  
  \item \code{void setInterceptable(String iface, String method,
    boolean interceptable)}: Define se os métodos de uma determinada interface devem ou não ser interceptados pelo interceptador servidor.
  
  \item \code{boolean isInterceptable(String iface, String method)}: Consulta se o método está sendo interceptado.
  
  \item \code{boolean isFaultToleranceEnable()}: Consulta se o mecanismo de tolerância a falhas esta ativado.
\end{itemize}

Os outros métodos do \emph{stub} do Serviço de Registro serão explicados em mais detalhes a seguir:

\begin{itemize}
  \item \code{RegistryIdentifier register(in ServiceOffer aServiceOffer)}: Registra um serviço no barramento. O serviço é descrito através de uma oferta de	serviço. Caso o serviço seja registrado com sucesso, a identificação do mesmo é	retornada. O identificador é importante para desregistrar a oferta.
  
  \item \code{void unregister(String registryId)}: Remove uma oferta de serviço do barramento.
  
  \item \code{ServiceOfferList find(FacetList facets)}: Busca uma ou mais ofertas de serviço no barramento que implementem todas as facetas discriminadas em \emph{facets}.
  
  \item \code{ServiceOfferList findByCriteria(FacetList facets,	PropertyList properties)}: Busca uma ou mais ofertas de serviço no barramento que implementem todas as facetas discriminadas em \emph{facets} e que atendam aos critérios descritos no parâmetro \emph{criteria}, que é uma lista de propriedades descrita através de strings no	formato chave = {valor1, valor2, ..., valorN}.
\end{itemize}

\subsection{Configurações avançadas}

\subsubsection{Definindo os níveis de log da API}
A API utiliza o log do Java, que possui os níveis de log descritos na classe
 \emph{java.util.logging.Level}. Para alterar o nível de log da API deve-se chamar o método \emph{setLogsLevel()} enviando o nível desejado como parâmetro.
Este método se encontra na classe \emph{tecgraf.openbus.util.Log}.

\subsubsection{Habilitando a política de cache das credenciais}
A API fornece uma forma de inicializar o barramento com a configuração desejada da política de validação de credenciais obtidas pelo interceptador servidor. Esta política permite que a API use um mecanismo de cache otimizando o desempenho do barramento.

Para usar uma política, basta especificá-la na inicialização através do método \emph{init} ou \emph{initWithFaultTolerance}. Para maiores informações sobre os tipos de política que podem ser definidos, vide a classe \emph{interceptors.CredentialValidationPolicy}. Por padrão, o barramento é inicializado com a política de sempre validar uma credencial interceptada no servidor.

\subsubsection{Definindo os \textit{timeouts} do mecanismo de tolerância a falhas}
Ao iniciar o barramento com o mecanismo de tolerância a falhas ativado, a API configura um \textit{timeout} para as requisições de forma que, se uma réplica demorar muito para responder, o interceptador tentará redirecionar a requisição para outra réplica. A API configura esse tempo de duas formas: (i) alterando o arquivo de configuração do próprio JacORB (jacorb.properties), e (ii) definindo a política de \textit{timeout} para cada objeto remoto.

Desta forma, se o desenvolvedor precisar alterar essas valores, é preciso alterar os tempos definidos nos atributos dentro do método \textit{initWithFaultTolerance}:
\begin{itemize}
\item jacorb.connection.client.connect\_timeout
\item jacorb.retries
\item jacorb.retry\_interval
\end{itemize}

O tempo padrão configurado máximo é de 3 minutos e é uma composição dos atributos mencionados.  Além disso, deve especificar explicitamente este valor no atributo \emph{totalTimeOut} também dentro do método \emph{initWithFaultTolerance}, pois ele é usado para definir a política. 

\subsection{Primeiros Passos}

Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e outra que consome serviços, sendo possível e natural uma aplicação híbrida que tanto oferte quanto consuma. Para ambos os tipos, existe uma certa dinâmica de programação já definida, e é justamente a explicitação dessa dinâmica que será o objetivo deste tópico.

Como facilitador, os processos serão demonstrados com base na demo Hello. De propósito, este é um demo muito simplório, que é composto de um módulo cliente e de outro servidor. O servidor oferta um serviço do tipo Hello num determinado barramento, enquanto que o cliente procura por este serviço no barramento e o utiliza.

\subsubsection{Conexão com o Barramento}

O primeiro passo é firmar uma conexão autenticada com o barramento, o que é necessário tanto para o cliente como para o servidor. Para se concluir a conexão é preciso:

\begin{itemize}
  \item Adquirir a instância que representa o barramento.
  \item Inicializar o barramento.
  \item Efetuar uma autenticação no barramento através de um dos métodos de conexão da API.
\end{itemize}

Existem três modos de autenticação frente ao barramento:

\begin{itemize}
  \item Par usuário e senha.
  \item Certificado digital.
  \item Utilização de uma credencial já existente e válida.
\end{itemize}

O primeiro é destinado normalmente aos clientes que estão acessando o barramento à procura de um serviço. O segundo é mais adequado ao processo servidor que registrará um determinado serviço no barramento. Já o terceiro é útil para aplicações que dependam de terceiros para realizar uma autenticação, ou seja, não tenham acesso a um par usuário/senha nem a um certificado, mas sim a um terceiro elemento que proveja uma credencial válida.

No caso da autenticação via certificado, o responsável pelo serviço deve encaminhar ao administrador do barramento o certificado do serviço, ou seja, um arquivo especial que contenha a chave pública do serviço, dentre outras informações pertinentes. O administrador deve fornecer o certificado do serviço de controle de acesso.

Um exemplo do código necessário para a conexão com o barramento pode ser visto no Código~\ref{lst:conexao}.

\begin{labeledcode}[java]{conexao}{Conexão com o Barramento}
import tecgraf.openbus.Openbus;
import tecgraf.openbus.util.CryptoUtils;

Openbus bus = Openbus.getInstance();

// host e porta apenas para fins de exemplo.
// args são argumentos da linha de comando e props são propriedades como as
// do Código 1. Ambos serão passados ao ORB em sua inicialização.
bus.init(args, props, "localhost", 2089);

RSAPrivateKey privateKey = CryptoUtils.readPrivateKey("HelloService.key");
X509Certificate acsCertificate =
  CryptoUtils.readCertificate("AccessControlService.crt");
  
IRegistryService registryService =
  bus.connect("HelloService", privateKey, acsCertificate);
\end{labeledcode}

\subsubsection{Serviço de Registro}

Um serviço pode ser colocado no barramento através de uma oferta de serviço (\emph{ServiceOffer}), que é uma estrutura que representa o serviço através de uma lista de propriedades (\emph{properties}) e de uma referência a um componente (\emph{member}) SCS. As definições em IDL dessas estruturas podem ser vistas no Código~\ref{lst:offer}.

\begin{labeledcode}[idl]{offer}{Definições de Ofertas de Serviço}
typedef sequence<string> PropertyValue;
struct Property {
    string name;
    PropertyValue value;
};

typedef sequence<Property> PropertyList;

struct ServiceOffer {
    PropertyList properties;
    scs::core::IComponent member;
};
\end{labeledcode}

A lista de propriedades pode ser utilizada para adicionar características para o serviço, a fim de facilitar a identificação por parte dos clientes.

A arquitetura do Openbus é baseada no modelo de componentes SCS. Os serviços são de fato representados por componentes, que podem apresentar distintas facetas(interfaces). Sendo assim, o primeiro passo para o registro de um serviço é criar um componente que represente esse serviço. Maiores informações sobre a criação de componentes SCS podem ser obtidas nos tutoriais desse projeto, mas um exemplo pode ser conferido no Código~\ref{lst:component}. Nesse exemplo, \emph{HelloImpl} é o nome da classe que implementa a faceta \emph{IHello}.

\begin{labeledcode}[java]{component}{Instanciação de um Componente SCS}

ComponentContext context = new ComponentContext(orb, bus.getRootPOA(),
    new ComponentId("Hello", (byte) 1, (byte) 0, (byte) 0, "Java"));
context.addFacet("IHello", IHelloHelper.id(), new HelloImpl());

\end{labeledcode}

O serviço a ser registrado no barramento deve ser descrito através de uma oferta de serviço, que é representada pela estrutura \emph{ServiceOffer}. Pendura-se nessa estrutura o serviço em si, que é representado através de um componente SCS e, opcionalmente, uma lista de propriedades referentes ao serviço. As propriedades devem ser descritas numa estrutura que representa uma lista de propriedades. Um exemplo pode ser conferido no Código~\ref{lst:registering}.

\begin{labeledcode}[java]{registering}{Registro de uma Oferta de Serviço}
// definição das propriedades
Property[] properties = new Property[1];
properties[0] = new Property();
properties[0].name = "description";
properties[0].value = new String[1];
properties[0].value[0] = "Serviço IHello";

// obtenção do objeto CORBA da faceta IComponent do componente
org.omg.CORBA.Object obj = instance.getIComponent();
IComponent component = IComponentHelper.narrow(obj);

// registro do serviço
ServiceOffer serviceOffer = new ServiceOffer(properties, component);
StringHolder registrationId = new StringHolder();
registryService.register(serviceOffer, registrationId);
\end{labeledcode}

É interessante (mas não obrigatório) também que um \emph{ShutdownHook} seja instalado na máquina virtual Java para garantir o término correto das conexões do ORB. Um exemplo pode ser conferido nas Listagens 7 e 8.

\begin{labeledcode}[java]{shutdownhook}{Exemplo de um \emph{ShutdownHook}}
private static class ShutdownThread extends Thread {
  @Override
  public void run() {
    Openbus bus = Openbus.getInstance();
    bus.disconnect();
    bus.getORB().shutdown(true);
    bus.getORB().destroy();
  }
}
\end{labeledcode}

\begin{labeledcode}[java]{hookinstall}{Instalação de um \emph{ShutdownHook}}
Runtime.getRuntime().addShutdownHook(new ShutdownThread());
\end{labeledcode}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou o serviço. O último passo necessário para finalizar o código do servidor é habilitar o processo servidor a escutar as requisições CORBA que serão direcionadas para o serviço ofertado, o que pode ser feito com o uso do método da API \emph{run()} descrito anteriormente na Seção \ref{api}.

\subsubsection{Processo Cliente}

Como o servidor, o cliente necessita de se autenticar ao barramento. Portanto, os mesmos passos aplicados ao servidor para a autenticação devem ser repetidos, com exceção de que o cliente geralmente se autentica através do mecanismo de usuário e senha, como no Código~\ref{lst:clientauth}.

\begin{labeledcode}[java]{clientauth}{Autenticação da Aplicação Cliente}
// userLogin e userPassword são variáveis String contendo o 
// nome de usuário e senha.
IRegistryService registryService = bus.connect(userLogin, userPassword);
\end{labeledcode}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o serviço desejado. Isso pode ser feito através de uma chamada ao método \emph{find()} do Serviço de Registro, que retorna uma lista de ofertas de serviço que implementam a faceta que o usuário deseja. Um exemplo pode ser conferido no Código~\ref{lst:clientsearch}.

\begin{labeledcode}[java]{clientsearch}{Busca por Ofertas de Serviço}
// busca no barramento serviços que implementem uma faceta de nome IHello.
// uma lista de *ofertas de serviço* é retornada para o usuário.
ServiceOffer[] servicesOffers =
  registryService.find(new String[] { "IHello" });

// nessa demo há somente uma oferta de serviço publicada, então simplesmente
// acessamos a primeira da lista.
ServiceOffer serviceOffer = servicesOffers[0];
\end{labeledcode}

Como visto anteriormente, a oferta de serviço contém uma referência para um componente SCS ou, mais especificamente, para sua faceta IComponent. Como esse componente pode apresentar diversas facetas, o usuário deve obter a faceta que deseja utilizar. No exemplo há somente uma faceta além das facetas básicas do modelo SCS, a IHello. A faceta recebida na oferta, IComponent, oferece métodos (\emph{getFacet} e \emph{getFacetByName}) para que o usuário possa obter um objeto CORBA que represente a faceta desejada. De posse do objeto CORBA, o usuário deve efetuar um \emph{narrow} para mapeá-lo para a interface desejada e daí em diante o programador estará apto a utilizar essa faceta / serviço. Um exemplo pode ser visto no Código~\ref{lst:clientfacet}.

\begin{labeledcode}[java]{clientfacet}{Acesso à Faceta Desejada}
// obtenção da faceta IHello
IComponent component = serviceOffer.member;
org.omg.CORBA.Object helloObject = component.getFacetByName("IHello");
IHello hello = IHelloHelper.narrow(helloObject);

// utilização da faceta / serviço IHello
hello.sayHello();
\end{labeledcode}

Os códigos completos podem ser conferidos nas demos do projeto.

\end{document}
